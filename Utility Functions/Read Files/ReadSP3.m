function pvt = ReadSP3(filename, cmToApcFlag,strictConstNumFlag,atxData)% TrueEphem = readNGA( filename )% TrueEphem is a n x 12 matrix. Each row of TrueEphem includes% [ GPS week, GPS sec, PRN, x, y, z, Clock drift, dx, dy, dz, d(Clock drift), Event Flag ]% No mathematical processing --- the value of each element is identical to that in the NGA file% Written by: Liang Heng  05/28/2009% functions called: err_chk, utc2leappvt = [];% if (nargin <= 1)%     outputFormat = [];% end[fid, message] = fopen(filename, 'rt');if (fid == -1)    fprintf(2, 'Error open %s: %s\n', filename, message);    returnendif (nargin < 3)    strictConstNumFlag = false;endif nargin < 4    atxData = [];endNumSV = -1;% a = [];% Default constellation is GPSconst = 'GPS';while 1    tline = fgetl(fid);    if ~ischar(tline)        break    end    switch tline(1:2)        case '#a'            PRNformat = ' %d';            DateTime = sscanf(tline(4:end), '%f' ,6);            NumEpochs = str2double(tline(33:39));            if tline(3) == 'P'                dataFormat = 'P %n%n%n%n%n%s%*[^\n]\n';            elseif tline(3) == 'V'                dataFormat = 'P %n%n%n%n%n%s%*[^\n]\nV %*[^\n]\n';            else                fprintf(2, 'Error: Unsupported file format %s.\n', tline(1:3));                fclose(fid);                return            end        case {'#c' '#d'}            PRNformat = 'G%d';            DateTime = sscanf(tline(4:end), '%f' ,6);            NumEpochs = str2double(tline(33:39));            if tline(3) == 'P'                dataFormat = 'PG%n%n%n%n%n%n%n%n%n%s%*[^\n]\n';            elseif tline(3) == 'V'                dataFormat = 'PG%n%n%n%n%n%n%n%n%n%s%*[^\n]\nVG%*[^\n]\n';            else                fprintf(2, 'Error: Unsupported file format %s.\n', tline(1:3));                fclose(fid);                return            end        case '%c'            if ~strcmp(tline(4),'c')                PRNformat = [tline(4) '%d'];                dataFormat(2) = tline(4);                if strcmp(tline(4),'R')                    const = 'GLO';                end            end                    case '%R' % added by kaz 11/21/2016 for igs final glonass            dataFormat(2) = 'R';            const = 'GLO';        case '##'            GPS_week_num = str2double(tline(4:7));            GPS_seconds = str2double(tline(9:23));            Epoch_interval = str2double(tline(25:38));        case '+ '            if NumSV < 0                NumSV = str2double(tline(2:8));                if NumSV < 1                    fprintf(2, 'Error: The number of SVs is %d.\n', NumSV);                    fclose(fid);                    return                end                s = sscanf(tline(10:end), PRNformat);                continue            end            if length(s) < NumSV                s = [s; sscanf(tline(10:end), PRNformat)];            end            %         case '++'            %             if length(a) < NumSV            %                 a = [a; sscanf(tline(10:end), '%d')];            %             end        case '* '            break    endend% a = a(1 : NumSV);C = textscan(fid, dataFormat, NumSV * NumEpochs, 'CollectOutput', 1, 'CommentStyle', '*');fclose(fid);array = C{1};len = size(array, 1);if len ~= NumSV * NumEpochs    fprintf(2, 'Error: Incorrect size of precise PVT array: %d\n', len);    returnendif strictConstNumFlag    % Limit number of SVs to maximum for that constellation (sometimes GLONASS    % actually has 25-26 SVs) and ensure that each block of time has that    % number of SVs\    switch const        case 'GPS'            nPrnOut = 32;        case 'GLO'            nPrnOut = 24;        case 'GAL'                    case 'BDS'                end    outArray = nan(nPrnOut*NumEpochs,9);    setInds = [0; find(diff(array(:,1)) < 1); length(array(:,1))];    setInds = [find(array(:,1) == array(1,1))-1; length(array(:,1))];    for tdx = 1:NumEpochs        for prn = 1:nPrnOut            setIndsi = (setInds(tdx)+1):setInds(tdx+1);            arrayi = array(setIndsi(array(setIndsi,1) == prn),:);            if ~isempty(arrayi)                outArray((tdx-1)*nPrnOut+prn,:) = arrayi;            else                outArray((tdx-1)*nPrnOut+prn,:) = [prn nan(1,8)];            end        end    end    array = outArray;    NumSV = nPrnOut;endpvt = struct('filename', filename, ...    'DateTime', DateTime', ...    'GPS_week_num', GPS_week_num, ...    'GPS_seconds', GPS_seconds, ...    'Epoch_interval', Epoch_interval, ...    'NumSV', NumSV, ...    'NumEpochs', NumEpochs, ...    'PRN', array(:, 1), ...    'clock_bias', array(:, 5) .* 1e-6, ...    'position', array(:, 2:4) .* 1000, ...    'Event', ~cellfun(@isempty, C{2}) );pvt.Event(abs(pvt.clock_bias) >= 0.999999) = true;pvt.Event(any(pvt.position == 0, 2)) = true;% %% IGS Time => GPS Time% [~, name, ~] = fileparts(filename);% pathstr = '~/Data/IGS_clk';% ext = '.clk';% clkfn = fullfile(pathstr, [name ext]);% if exist(clkfn, 'file')%     clk = ReadCLK(clkfn);%     if ~isempty(clk)%         pvt.clock_bias = pvt.clock_bias - reshape(repmat(clk, NumSV, 1), NumSV * NumEpochs, 1);%     end% else%     error('Failure IGS Time => GPS Time!');% end%% if nargin < 2%     return% end% %% Correct APC% dn = datenum(pvt.DateTime);% atx(atx(:, 4) == 0, 4) = 1e6;% atx(atx(:, 3) >= dn | atx(:, 4) <= dn, :) = [];% p = setdiff((1:32)', atx(:, 1));% atx = [atx; p zeros(length(p), 6)];% atx = sortrows(atx, 1);%% r = sqrt(sum(pvt.position .^ 2, 2));% for i = 1 : length(pvt.PRN)%     pvt.position(i, :) = pvt.position(i, :) .* (1 - atx(pvt.PRN(i), 7) / r(i));% end%% Correct APCif cmToApcFlag    % Pull sun position for each time in SP3 file        if isempty(strfind(path,'\mice\src\mic'))        AttachToMice();    end    t = GPS_seconds:Epoch_interval:(GPS_seconds+NumEpochs*Epoch_interval);    jd = gps2jd(GPS_week_num,t);    sunpos = zeros(3,length(t));    for i = 1:length(jd)        et          = cspice_str2et(['jd ' num2str(jd(i))]);        sunposi     = cspice_spkezr( 'sun',et , 'itrf93', 'none', 'earth');        sunpos(:,i) = sunposi(1:3)*1000;    end        PRNs = unique(array(:,1));        if ~isempty(atxData)        constNum = convertConstIndName(const);        atxDatai= atxData([atxData.type] == constNum);        epochi = GPS_seconds+604800*GPS_week_num;    end        for pdx = 1:NumSV        prn = PRNs(pdx);                if isempty(atxData)            offset = apcOffset(prn,GPS_week_num*604800+GPS_seconds,const);        else            svni = prn2svn(prn,jd(1),constNum);            if isnan(svni)                offset = nan(3,1);            else                adx = find([atxDatai.svn] == svni & [atxDatai.epochStart] <= epochi & [atxDatai.epochEnd] > epochi);                                if ~isempty(adx)                    offset = (atxDatai(adx).apc(1,:)')*1e-3;                else                    offset = nan(3,1);                end                            end                    end                inds = find(array(:,1) == prn);        for tdx = 1:NumEpochs            sunposi = sunpos(:,tdx);            svPosi  = pvt.position(inds(tdx),:)';                        % Build body axis rotation matrix            e = (sunposi-svPosi)./norm(sunposi-svPosi);            k = -svPosi./norm(svPosi);            % yhat = cross(e,k)./norm(cross(e,k));            j = cross(k,e)/norm(cross(k,e));            i = cross(j,k)/norm(cross(j,k));                        R = [i j k];            offsetECEF = R*offset;            pvt.position(inds(tdx),:) = svPosi+offsetECEF;                    end    endend